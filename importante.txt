predicate;

use std::bytes::Bytes;
use std::string::String;
use std::primitive_conversions::u64::*;
use std::{ecr::{ec_recover_r1, ec_recover}, b512::B512};
use std::result::Result;
use std::ecr::EcRecoverError;
use std::hash::*;
use std::tx::tx_id;
use std::tx::tx_witness_data;
use std::tx::tx_witness_data_length;
use std::tx::tx_witnesses_count;
use std::tx::GTF_WITNESS_DATA;
use std::tx::GTF_SCRIPT_WITNESS_AT_INDEX;


struct Normal {
  signature: B512,
}

enum Signature {
  webauth: WebAuthn, // 0
  normal: Normal, // 1
}

struct WebAuthn {
  signature: B512,
  prefix_size: u64,
  suffix_size: u64,
  auth_data_size: u64,
  prefix: raw_slice,
  suffix: raw_slice,
  auth_data: raw_slice,
}


const ASCII_MAP: [u8; 16] = [
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102
];

pub fn b256_to_ascii_bytes(val: b256) -> Bytes {
    let bytes = Bytes::from(val);
    let mut ascii_bytes = Bytes::with_capacity(64);
    let mut idx = 0;

    while idx < 32 {
        let b = bytes.get(idx).unwrap();
        ascii_bytes.push(ASCII_MAP[(b >> 4).as_u64()]);
        ascii_bytes.push(ASCII_MAP[(b & 15).as_u64()]);
	    idx = idx + 1;
    }

    ascii_bytes
}


// The address of the predicate.
configurable {
    SIGNERS: [b256; 10] = [
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
        0x0000000000000000000000000000000000000000000000000000000000000000,
    ],
    SIGNATURES_COUNT: u64 = 0,
    HASH_PREDICATE: b256 = 0x0000000000000000000000000000000000000000000000000000000000000000
}


fn get_webauthn_digest(webauthn: WebAuthn, sig_ptr: raw_ptr, tx_id: Bytes) -> b256 {
  // enum + signature + prefix_size + suffix_size + auth_data_size
  let offset_data = __size_of::<u64>() + __size_of::<B512>() + __size_of::<u64>() + __size_of::<u64>() + __size_of::<u64>();
  let offset_data_ptr = sig_ptr.add::<u8>(offset_data);
  // Get prefix bytes
  let prefix_buf = raw_slice::from_parts::<u8>(offset_data_ptr, webauthn.prefix_size);
  let prefix_bytes = Bytes::from(prefix_buf);
  // Get suffix bytes
  let suffix_ptr = offset_data_ptr.add::<u8>(webauthn.prefix_size);
  let suffix_buf = raw_slice::from_parts::<u8>(suffix_ptr, webauthn.suffix_size);
  let suffix_bytes = Bytes::from(suffix_buf);
  // Get Auth bytes
  let auth_data_ptr = offset_data_ptr.add::<u8>(webauthn.prefix_size).add::<u8>(webauthn.suffix_size);
  let auth_data_buf = raw_slice::from_parts::<u8>(auth_data_ptr, webauthn.auth_data_size);
  let auth_data_bytes = Bytes::from(auth_data_buf);
  // Create client hash
  let mut client_data = Bytes::new();
  client_data.append(prefix_bytes);
  client_data.append(tx_id);
  client_data.append(suffix_bytes);
  let client_hash = sha256(client_data);
  // Create message data
  let mut message = Bytes::new();
  message.append(auth_data_bytes);
  message.append(Bytes::from(client_hash));
  // Create digest return
  return sha256(message);
}


fn verify_exists_signer(public_key: b256) -> u64 {
    //verify if the public key is one of the signers
    let mut i_signer = 0;
    while i_signer < tx_witnesses_count() {
        if (public_key == SIGNERS[i_signer]) {
            return 1;
        }
        i_signer += 1;
    }
    return 0;
}

fn main() -> bool {
  
  // Get the transaction hash on bytes format
  let tx_bytes = b256_to_ascii_bytes(tx_id());
  let witness_count = tx_witnesses_count();

  // if(witness_count == 0 || witness_count < SIGNATURES_COUNT) {
  //     return false;
  // }



  let mut i_witnesses = 0;
  let mut valid_signatures:u64 = 0;

  if(HASH_PREDICATE != HASH_PREDICATE) {
      return false;
  }

  //recover the public key from the signature
  while i_witnesses < witness_count {
    let sig_ptr = __gtf::<raw_ptr>(i_witnesses, GTF_WITNESS_DATA);
    
    match sig_ptr.read::<Signature>() {
    Signature::webauth(webauthn) => {
      let digest = get_webauthn_digest(webauthn, sig_ptr, tx_bytes);
      let _public_key = ec_recover_r1(webauthn.signature, digest).unwrap();
      valid_signatures += verify_exists_signer(sha256(_public_key.into()));
      return verify_exists_signer(sha256(_public_key.into())) == 1;
    }
    Signature::normal(normal) => {
      let _public_key = ec_recover(normal.signature, sha256(tx_bytes)).unwrap();
      valid_signatures += verify_exists_signer(sha256(_public_key.into()));
      return verify_exists_signer(sha256(_public_key.into())) == 1;
    }
  };

    i_witnesses += 1;
  }

  // Check if the number of valid signatures is greater than the required
  return valid_signatures >= SIGNATURES_COUNT;
}
