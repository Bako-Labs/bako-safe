script;

use std::{
    alloc::alloc,
    bytes::Bytes,
    ecr::{
        ec_recover_address,
        ec_recover_address_r1,
    },
    assert::assert,
    hash::*,
    tx::{
        GTF_WITNESS_DATA,
        tx_id,
        tx_witness_data,
        tx_witnesses_count,
    },
};

use libraries::{
    ascii::b256_to_ascii_bytes,
    constants::{
        BYTE_WITNESS_TYPE_FUEL,
        BYTE_WITNESS_TYPE_WEBAUTHN,
        EMPTY_SIGNERS,
        INVALID_ADDRESS,
        MAX_SIGNERS,
    },
    entities::{
        Signature,
        WebAuthn,
    },
    recover_signature::{
        fuel_verify,
        webauthn_verify,
    },
    validations::{
        check_duplicated_signers,
        check_signer_exists,
    },
};

use std::b512::B512;

enum SignatureType {
    WebAuthn: WebAuthnHeader,
    Fuel: B512,
}

struct WebAuthnHeader {
    pub signature: B512,
    pub prefix_size: u64,
    pub suffix_size: u64,
    pub message_data_size: u64,
}

// This is a prefix to skip signatures that are not generated by BakoSafe
// BAKO string to bytes -> 66, 65, 75, 79 -> 0x42414b4f
const PREFIX_BAKO_SIG: [u8; 4] = [66, 65, 75, 79];

fn write_bytes(target_ptr: raw_ptr, src_ptr: raw_ptr, size: u64) {
    asm(target_ptr: target_ptr, src_ptr: src_ptr, size: size) {
        mcp target_ptr src_ptr size;
    };
}

fn get_webautn_digest(
    webauthn: WebAuthnHeader,
    ptr_data: raw_ptr,
    tx_id_bytes: Bytes,
) -> b256 {
    let tx_id_size = __size_of::<B512>();
    // Sizes
    let size_payload: u64 = webauthn.prefix_size + tx_id_size + webauthn.suffix_size;
    // Data ptr
    let ptr_data_suffix = ptr_data.add_uint_offset(webauthn.prefix_size);
    let ptr_data_msg = ptr_data_suffix.add_uint_offset(webauthn.suffix_size);
    // Bytes ptr
    let ptr_bytes = alloc::<u8>(size_payload + __size_of::<b256>());
    let ptr_bytes_tx = ptr_bytes.add_uint_offset(webauthn.prefix_size);
    let ptr_bytes_suffix = ptr_bytes_tx.add_uint_offset(tx_id_size);
    let ptr_bytes_msg = ptr_bytes_suffix.add_uint_offset(webauthn.suffix_size);
    let ptr_bytes_hash = ptr_bytes_msg.add_uint_offset(webauthn.message_data_size);


    // Write bytes
    write_bytes(ptr_bytes, ptr_data, webauthn.suffix_size);
    write_bytes(ptr_bytes_tx, tx_id_bytes.ptr(), tx_id_size);
    write_bytes(ptr_bytes_suffix, ptr_data_suffix, webauthn.suffix_size);
    write_bytes(ptr_bytes_msg, ptr_data_msg, webauthn.suffix_size);

    let mut digest = b256::zero();
    asm(
        ptr_bytes: ptr_bytes,
        ptr_hash: ptr_bytes_hash,
        ptr_msg: ptr_bytes_msg,
        size_auth: size_payload,
        size_hash: webauthn.message_data_size + __size_of::<b256>(),
        digest: digest,
    ) {
        s256 ptr_hash ptr_bytes size_auth;
        s256 digest ptr_msg size_hash;
    };

    return digest;
}

fn verify_webauth(digest: b256, webauthn: WebAuthnHeader) -> Address {
    match ec_recover_address_r1(webauthn.signature, digest) {
        Result::Ok(address) => address,
        _ => Address::zero(),
    }
}

fn verify_prefix(witness_ptr: raw_ptr) -> bool {
    asm(
        prefix: PREFIX_BAKO_SIG,
        witness_ptr: witness_ptr,
        size: 4,
        r1,
    ) {
        meq r1 witness_ptr prefix size;
        r1: bool
    }
}

fn main(tx_id: b256, address: b256) -> bool {
    let mut witness_ptr = __gtf::<raw_ptr>(0, GTF_WITNESS_DATA);
    log(witness_ptr.read::<u64>());
    log(witness_ptr.add_uint_offset(__size_of::<u64>()).read::<B512>());
    
    let enum_sig = witness_ptr.read::<u64>();
    let sig_ptr = witness_ptr.add_uint_offset(__size_of::<u64>());

    return match enum_sig {
        BYTE_WITNESS_TYPE_WEBAUTHN => {
            let webauthn = sig_ptr.read::<WebAuthnHeader>();
            let digest = get_webautn_digest(webauthn, sig_ptr, b256_to_ascii_bytes(tx_id));
            let _address = verify_webauth(digest, webauthn);
            log(_address);
            true
        },
        BYTE_WITNESS_TYPE_FUEL => {
            let fuel = sig_ptr.read::<B512>();
            let _address = fuel_verify(
                fuel,
                b256_to_ascii_bytes(tx_id),
            );
            log(01);
            log(_address);
            true
        },
        _ => false,
    }
}
