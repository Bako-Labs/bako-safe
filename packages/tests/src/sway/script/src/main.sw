script;

use std::{
    alloc::alloc,
    bytes::Bytes,
    ecr::{
        ec_recover_address,
        ec_recover_address_r1,
    },
    hash::*,
    tx::{
        GTF_WITNESS_DATA,
        tx_id,
        tx_witness_data,
        tx_witnesses_count,
    },
};

use libraries::{
    ascii::b256_to_ascii_bytes,
    constants::{
        BYTE_WITNESS_TYPE_FUEL,
        BYTE_WITNESS_TYPE_WEBAUTHN,
        EMPTY_SIGNERS,
        INVALID_ADDRESS,
        MAX_SIGNERS,
    },
    entities::{
        Signature,
        WebAuthn,
    },
    recover_signature::{
        fuel_verify,
        webauthn_verify,
    },
    validations::{
        check_duplicated_signers,
        check_signer_exists,
    },
};

use std::b512::B512;

enum SignatureType {
    WebAuthn: WebAuthnHeader,
    Fuel: B512,
}

struct WebAuthnHeader {
    pub signature: B512,
    pub prefix_size: u64,
    pub suffix_size: u64,
    pub message_data_size: u64,
}

// This is a prefix to skip signatures that are not generated by BakoSafe
// BAKO string to bytes -> 66, 65, 75, 79 -> 0x42414b4f
const PREFIX_BAKO_SIG: [u8; 4] = [66, 65, 75, 79];

fn get_webautn_digest(
    webauthn: WebAuthnHeader,
    witness_ptr: raw_ptr,
    ref mut tx_id_bytes: Bytes,
) -> b256 {
    let size_header = __size_of::<WebAuthnHeader>();
    let tx_id_size = __size_of::<B512>();
    // Offsets
    let offset_tx: u64 = webauthn.prefix_size;
    let offset_suffix: u64 = offset_tx + tx_id_size;
    let offset_msg: u64 = offset_suffix + webauthn.suffix_size;
    // Sizes
    let size_payload: u64 = offset_msg + webauthn.message_data_size;
    let size_bytes: u64 = size_payload + __size_of::<b256>();
    let size_hash: u64 = webauthn.message_data_size + __size_of::<b256>();
    // Bytes ptr
    let ptr_data = witness_ptr.add_uint_offset(size_header);
    let ptr_bytes = alloc::<u8>(size_bytes);
    let ptr_tx = ptr_bytes.add_uint_offset(offset_tx);
    let ptr_msg = ptr_bytes.add_uint_offset(offset_msg);
    let ptr_hash = ptr_bytes.add_uint_offset(size_payload);

    let mut digest = b256::zero();
    asm(
        ptr_data: ptr_data,
        ptr_bytes: ptr_bytes,
        ptr_tx: ptr_tx,
        ptr_hash: ptr_hash,
        ptr_msg: ptr_msg,
        size_auth: offset_msg,
        size_payload: size_payload,
        size_hash: size_hash,
        tx_src: tx_id_bytes.ptr(),
        tx_size: tx_id_size,
        digest: digest,
    ) {
        mcp ptr_bytes ptr_data size_payload;
        mcp ptr_tx tx_src tx_size;
        s256 ptr_hash ptr_bytes size_auth;
        s256 digest ptr_msg size_hash;
    };
    return digest;
}

fn verify_webauth(digest: b256, webauthn: WebAuthnHeader) -> Address {
    match ec_recover_address_r1(webauthn.signature, digest) {
        Result::Ok(address) => address,
        _ => Address::zero(),
    }
}

fn verify_prefix(witness_ptr: raw_ptr) -> bool {
    let prefix = witness_ptr.read::<[u8; 4]>();
    return (prefix[0] == PREFIX_BAKO_SIG[0] && prefix[1] == PREFIX_BAKO_SIG[1] && prefix[2] == PREFIX_BAKO_SIG[2] && prefix[3] == PREFIX_BAKO_SIG[3]);
}

fn main(tx_id: b256, address: b256) -> bool {
    let mut witness_ptr = __gtf::<raw_ptr>(0, GTF_WITNESS_DATA);

    if (verify_prefix(witness_ptr)) {
        witness_ptr = witness_ptr.add_uint_offset(4); // skip bako prefix
        let signature = witness_ptr.read::<SignatureType>();
        witness_ptr = witness_ptr.add_uint_offset(__size_of::<u64>()); // skip enum size
        let mut tx_id_bytes = b256_to_ascii_bytes(tx_id);

        return match signature {
            SignatureType::WebAuthn(webauthn) => {
                verify_webauth(
                    get_webautn_digest(webauthn, witness_ptr, tx_id_bytes),
                    webauthn,
                ) == Address::from(address)
            },
            SignatureType::Fuel(_fuel) => false,
            _ => false,
        };
    }

    return false;
}
